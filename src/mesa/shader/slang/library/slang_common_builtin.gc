
//
// TODO:
// - implement texture1D, texture2D, texture3D, textureCube,
// - implement shadow1D, shadow2D,
//

//
// From Shader Spec, ver. 1.10, rev. 59
//

const int gl_MaxLights = 8;
const int gl_MaxClipPlanes = 6;
const int gl_MaxTextureUnits = 8;
const int gl_MaxTextureCoords = 8;
const int gl_MaxVertexAttribs = 16;
const int gl_MaxVertexUniformComponents = 512;
const int gl_MaxVaryingFloats = 32;
const int gl_MaxVertexTextureImageUnits = 0;
const int gl_MaxCombinedTextureImageUnits = 2;
const int gl_MaxTextureImageUnits = 2;
const int gl_MaxFragmentUniformComponents = 64;
const int gl_MaxDrawBuffers = 1;

uniform mat4 gl_ModelViewMatrix;
uniform mat4 gl_ProjectionMatrix;
uniform mat4 gl_ModelViewProjectionMatrix;
uniform mat4 gl_TextureMatrix[gl_MaxTextureCoords];

uniform mat3 gl_NormalMatrix;

uniform mat4 gl_ModelViewMatrixInverse;
uniform mat4 gl_ProjectionMatrixInverse;
uniform mat4 gl_ModelViewProjectionMatrixInverse;
uniform mat4 gl_TextureMatrixInverse[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixTranspose;
uniform mat4 gl_ProjectionMatrixTranspose;
uniform mat4 gl_ModelViewProjectionMatrixTranspose;
uniform mat4 gl_TextureMatrixTranspose[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixInverseTranspose;
uniform mat4 gl_ProjectionMatrixInverseTranspose;
uniform mat4 gl_ModelViewProjectionMatrixInverseTranspose;
uniform mat4 gl_TextureMatrixInverseTranspose[gl_MaxTextureCoords];

uniform float gl_NormalScale;

struct gl_DepthRangeParameters {
    float near;
    float far;
    float diff;
};

uniform gl_DepthRangeParameters gl_DepthRange;

uniform vec4 gl_ClipPlane[gl_MaxClipPlanes];

struct gl_PointParameters {
    float size;
    float sizeMin;
    float sizeMax;
    float fadeThresholdSize;
    float distanceConstantAttenuation;
    float distanceLinearAttenuation;
    float distanceQuadraticAttenuation;
};

uniform gl_PointParameters gl_Point;

struct gl_MaterialParameters {
    vec4 emission;
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    float shininess;
};

uniform gl_MaterialParameters gl_FrontMaterial;
uniform gl_MaterialParameters gl_BackMaterial;

struct gl_LightSourceParameters {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    vec4 position;
    vec4 halfVector;
    vec3 spotDirection;
    float spotExponent;
    float spotCutoff;
    float spotCosCutoff;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
};

uniform gl_LightSourceParameters gl_LightSource[gl_MaxLights];

struct gl_LightModelParameters {
    vec4 ambient;
};

uniform gl_LightModelParameters gl_LightModel;

struct gl_LightModelProducts {
    vec4 sceneColor;
};

uniform gl_LightModelProducts gl_FrontLightModelProduct;
uniform gl_LightModelProducts gl_BackLightModelProduct;

struct gl_LightProducts {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
};

uniform gl_LightProducts gl_FrontLightProduct[gl_MaxLights];
uniform gl_LightProducts gl_BackLightProduct[gl_MaxLights];

uniform vec4 gl_TextureEnvColor[gl_MaxTextureImageUnits];
uniform vec4 gl_EyePlaneS[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneT[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneR[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneQ[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneS[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneT[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneR[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneQ[gl_MaxTextureCoords];

struct gl_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

uniform gl_FogParameters gl_Fog;

//
// 8.1 Angle and Trigonometry Functions
//

float radians (float deg) {
    return 3.141593 * deg / 180.0;
}

vec2 radians (vec2 deg) {
    return vec2 (3.141593) * deg / vec2 (180.0);
}

vec3 radians (vec3 deg) {
    return vec3 (3.141593) * deg / vec3 (180.0);
}

vec4 radians (vec4 deg) {
    return vec4 (3.141593) * deg / vec4 (180.0);
}

float degrees (float rad) {
    return 180.0 * rad / 3.141593;
}

vec2 degrees (vec2 rad) {
    return vec2 (180.0) * rad / vec2 (3.141593);
}

vec3 degrees (vec3 rad) {
    return vec3 (180.0) * rad / vec3 (3.141593);
}

vec4 degrees (vec4 rad) {
    return vec4 (180.0) * rad / vec4 (3.141593);
}

float sin (float angle) {
    float x;
    __asm float_sine x, angle;
    return x;
}

vec2 sin (vec2 angle) {
    vec2 u;
    u.x = sin (angle.x);
    u.y = sin (angle.y);
    return u;
}

vec3 sin (vec3 angle) {
    vec3 u;
    u.x = sin (angle.x);
    u.y = sin (angle.y);
    u.z = sin (angle.z);
    return u;
}

vec4 sin (vec4 angle) {
    vec4 u;
    u.x = sin (angle.x);
    u.y = sin (angle.y);
    u.z = sin (angle.z);
    u.w = sin (angle.w);
    return u;
}

float cos (float angle) {
    return sin (angle + 1.5708);
}

vec2 cos (vec2 angle) {
    vec2 u;
    u.x = cos (angle.x);
    u.y = cos (angle.y);
    return u;
}

vec3 cos (vec3 angle) {
    vec3 u;
    u.x = cos (angle.x);
    u.y = cos (angle.y);
    u.z = cos (angle.z);
    return u;
}

vec4 cos (vec4 angle) {
    vec4 u;
    u.x = cos (angle.x);
    u.y = cos (angle.y);
    u.z = cos (angle.z);
    u.w = cos (angle.w);
    return u;
}

float tan (float angle) {
    return sin (angle) / cos (angle);
}

vec2 tan (vec2 angle) {
    vec2 u;
    u.x = tan (angle.x);
    u.y = tan (angle.y);
    return u;
}

vec3 tan (vec3 angle) {
    vec3 u;
    u.x = tan (angle.x);
    u.y = tan (angle.y);
    u.z = tan (angle.z);
    return u;
}

vec4 tan (vec4 angle) {
    vec4 u;
    u.x = tan (angle.x);
    u.y = tan (angle.y);
    u.z = tan (angle.z);
    u.w = tan (angle.w);
    return u;
}

float asin (float x) {
    float y;
    __asm float_arcsine y, x;
    return y;
}

vec2 asin (vec2 v) {
    vec2 u;
    u.x = asin (v.x);
    u.y = asin (v.y);
    return u;
}

vec3 asin (vec3 v) {
    vec3 u;
    u.x = asin (v.x);
    u.y = asin (v.y);
    u.z = asin (v.z);
    return u;
}

vec4 asin (vec4 v) {
    vec4 u;
    u.x = asin (v.x);
    u.y = asin (v.y);
    u.z = asin (v.z);
    u.w = asin (v.w);
    return u;
}

float acos (float x) {
    return 1.5708 - asin (x);
}

vec2 acos (vec2 v) {
    vec2 u;
    u.x = acos (v.x);
    u.y = acos (v.y);
    return u;
}

vec3 acos (vec3 v) {
    vec3 u;
    u.x = acos (v.x);
    u.y = acos (v.y);
    u.z = acos (v.z);
    return u;
}

vec4 acos (vec4 v) {
    vec4 u;
    u.x = acos (v.x);
    u.y = acos (v.y);
    u.z = acos (v.z);
    u.w = acos (v.w);
    return u;
}

float atan (float y_over_x) {
    float z;
    __asm float_arctan z, y_over_x;
    return z;
}

vec2 atan (vec2 y_over_x) {
    vec2 u;
    u.x = atan (y_over_x.x);
    u.y = atan (y_over_x.y);
    return u;
}

vec3 atan (vec3 y_over_x) {
    vec3 u;
    u.x = atan (y_over_x.x);
    u.y = atan (y_over_x.y);
    u.z = atan (y_over_x.z);
    return u;
}

vec4 atan (vec4 y_over_x) {
    vec4 u;
    u.x = atan (y_over_x.x);
    u.y = atan (y_over_x.y);
    u.z = atan (y_over_x.z);
    u.w = atan (y_over_x.w);
    return u;
}

float atan (float y, float x) {
    float z;
    z = atan (y / x);
    if (x < 0.0)
    {
        if (y < 0.0)
            return z - 3.141593;
        return z + 3.141593;
    }
    return z;
}

vec2 atan (vec2 u, vec2 v) {
    vec2 t;
    t.x = atan (u.x, v.x);
    t.y = atan (u.y, v.y);
    return t;
}

vec3 atan (vec3 u, vec3 v) {
    vec3 t;
    t.x = atan (u.x, v.x);
    t.y = atan (u.y, v.y);
    t.z = atan (u.z, v.z);
    return t;
}

vec4 atan (vec4 u, vec4 v) {
    vec4 t;
    t.x = atan (u.x, v.x);
    t.y = atan (u.y, v.y);
    t.z = atan (u.z, v.z);
    t.w = atan (u.w, v.w);
    return t;
}

//
// 8.2 Exponential Functions
//

float pow (float x, float y) {
    float p;
    __asm float_power p, x, y;
    return p;
}

vec2 pow (vec2 v, vec2 u) {
    vec2 t;
    t.x = pow (v.x, u.x);
    t.y = pow (v.y, u.y);
    return t;
}

vec3 pow (vec3 v, vec3 u) {
    vec3 t;
    t.x = pow (v.x, u.x);
    t.y = pow (v.y, u.y);
    t.z = pow (v.z, u.z);
    return t;
}

vec4 pow (vec4 v, vec4 u) {
    vec4 t;
    t.x = pow (v.x, u.x);
    t.y = pow (v.y, u.y);
    t.z = pow (v.z, u.z);
    t.w = pow (v.w, u.w);
    return t;
}

float exp (float x) {
    return pow (2.71828183, x);
}

vec2 exp (vec2 v) {
    return pow (vec2 (2.71828183), v);
}

vec3 exp (vec3 v) {
    return pow (vec3 (2.71828183), v);
}

vec4 exp (vec4 v) {
    return pow (vec4 (2.71828183), v);
}

float log2 (float x) {
    float y;
    __asm float_log2 y, x;
    return y;
}

vec2 log2 (vec2 v) {
    vec2 u;
    u.x = log2 (v.x);
    u.y = log2 (v.y);
    return u;
}

vec3 log2 (vec3 v) {
    vec3 u;
    u.x = log2 (v.x);
    u.y = log2 (v.y);
    u.z = log2 (v.z);
    return u;
}

vec4 log2 (vec4 v) {
    vec4 u;
    u.x = log2 (v.x);
    u.y = log2 (v.y);
    u.z = log2 (v.z);
    u.w = log2 (v.w);
    return u;
}

float log (float x) {
    return log2 (x) / log2 (2.71828183);
}

vec2 log (vec2 v) {
    return log2 (v) / log2 (vec2 (2.71828183));
}

vec3 log (vec3 v) {
    return log2 (v) / log2 (vec3 (2.71828183));
}

vec4 log (vec4 v) {
    return log2 (v) / log2 (vec4 (2.71828183));
}

float exp2 (float x) {
    return pow (2.0, x);
}

vec2 exp2 (vec2 v) {
    return pow (vec2 (2.0), v);
}

vec3 exp2 (vec3 v) {
    return pow (vec3 (2.0), v);
}

vec4 exp2 (vec4 v) {
    return pow (vec4 (2.0), v);
}

float sqrt (float x) {
    return pow (x, 0.5);
}

vec2 sqrt (vec2 v) {
    return pow (v, vec2 (0.5));
}

vec3 sqrt (vec3 v) {
    return pow (v, vec3 (0.5));
}

vec4 sqrt (vec4 v) {
    return pow (v, vec4 (0.5));
}

float inversesqrt (float x) {
    return 1.0 / sqrt (x);
}

vec2 inversesqrt (vec2 v) {
    return vec2 (1.0) / sqrt (v);
}

vec3 inversesqrt (vec3 v) {
    return vec3 (1.0) / sqrt (v);
}

vec4 inversesqrt (vec4 v) {
    return vec4 (1.0) / sqrt (v);
}

//
// 8.3 Common Functions
//

float abs (float x) {
    return x >= 0.0 ? x : -x;
}

vec2 abs (vec2 v) {
    vec2 u;
    u.x = abs (v.x);
    u.y = abs (v.y);
    return u;
}

vec3 abs (vec3 v) {
    vec3 u;
    u.x = abs (v.x);
    u.y = abs (v.y);
    u.z = abs (v.z);
    return u;
}

vec4 abs (vec4 v) {
    vec4 u;
    u.x = abs (v.x);
    u.y = abs (v.y);
    u.z = abs (v.z);
    u.w = abs (v.w);
    return u;
}

float sign (float x) {
    return x > 0.0 ? 1.0 : x < 0.0 ? -1.0 : 0.0;
}

vec2 sign (vec2 v) {
    vec2 u;
    u.x = sign (v.x);
    u.y = sign (v.y);
    return u;
}

vec3 sign (vec3 v) {
    vec3 u;
    u.x = sign (v.x);
    u.y = sign (v.y);
    u.z = sign (v.z);
    return u;
}

vec4 sign (vec4 v) {
    vec4 u;
    u.x = sign (v.x);
    u.y = sign (v.y);
    u.z = sign (v.z);
    u.w = sign (v.w);
    return u;
}

float floor (float x) {
    float y;
    __asm float_floor y, x;
    return y;
}

vec2 floor (vec2 v) {
    vec2 u;
    u.x = floor (v.x);
    u.y = floor (v.y);
    return u;
}

vec3 floor (vec3 v) {
    vec3 u;
    u.x = floor (v.x);
    u.y = floor (v.y);
    u.z = floor (v.z);
    return u;
}

vec4 floor (vec4 v) {
    vec4 u;
    u.x = floor (v.x);
    u.y = floor (v.y);
    u.z = floor (v.z);
    u.w = floor (v.w);
    return u;
}

float ceil (float x) {
    float y;
    __asm float_ceil y, x;
    return y;
}

vec2 ceil (vec2 v) {
    vec2 u;
    u.x = ceil (v.x);
    u.y = ceil (v.y);
    return u;
}

vec3 ceil (vec3 v) {
    vec3 u;
    u.x = ceil (v.x);
    u.y = ceil (v.y);
    u.z = ceil (v.z);
    return u;
}

vec4 ceil (vec4 v) {
    vec4 u;
    u.x = ceil (v.x);
    u.y = ceil (v.y);
    u.z = ceil (v.z);
    u.w = ceil (v.w);
    return u;
}

float fract (float x) {
    return x - floor (x);
}

vec2 fract (vec2 v) {
    return v - floor (v);
}

vec3 fract (vec3 v) {
    return v - floor (v);
}

vec4 fract (vec4 v) {
    return v - floor (v);
}

float mod (float x, float y) {
    return x - y * floor (x / y);
}

vec2 mod (vec2 v, float u) {
    return v - u * floor (v / u);
}

vec3 mod (vec3 v, float u) {
    return v - u * floor (v / u);
}

vec4 mod (vec4 v, float u) {
    return v - u * floor (v / u);
}

vec2 mod (vec2 v, vec2 u) {
    return v - u * floor (v / u);
}

vec3 mod (vec3 v, vec3 u) {
    return v - u * floor (v / u);
}

vec4 mod (vec4 v, vec4 u) {
    return v - u * floor (v / u);
}

float min (float x, float y) {
    return x < y ? x : y;
}

vec2 min (vec2 v, vec2 u) {
    vec2 t;
    t.x = min (v.x, u.x);
    t.y = min (v.y, u.y);
    return t;
}

vec3 min (vec3 v, vec3 u) {
    vec3 t;
    t.x = min (v.x, u.x);
    t.y = min (v.y, u.y);
    t.z = min (v.z, u.z);
    return t;
}

vec4 min (vec4 v, vec4 u) {
    vec4 t;
    t.x = min (v.x, u.x);
    t.y = min (v.y, u.y);
    t.z = min (v.z, u.z);
    t.w = min (v.w, u.w);
    return t;
}

vec2 min (vec2 v, float y) {
    return min (v, vec2 (y));
}

vec3 min (vec3 v, float y) {
    return min (v, vec3 (y));
}

vec4 min (vec4 v, float y) {
    return min (v, vec4 (y));
}

float max (float x, float y) {
    return x < y ? y : x;
}

vec2 max (vec2 v, vec2 u) {
    vec2 t;
    t.x = max (v.x, u.x);
    t.y = max (v.y, u.y);
    return t;
}

vec3 max (vec3 v, vec3 u) {
    vec3 t;
    t.x = max (v.x, u.x);
    t.y = max (v.y, u.y);
    t.z = max (v.z, u.z);
    return t;
}

vec4 max (vec4 v, vec4 u) {
    vec4 t;
    t.x = max (v.x, u.x);
    t.y = max (v.y, u.y);
    t.z = max (v.z, u.z);
    t.w = max (v.w, u.w);
    return t;
}

vec2 max (vec2 v, float y) {
    return max (v, vec2 (y));
}

vec3 max (vec3 v, float y) {
    return max (v, vec3 (y));
}

vec4 max (vec4 v, float y) {
    return max (v, vec4 (y));
}

float clamp (float x, float minVal, float maxVal) {
    return min (max (x, minVal), maxVal);
}

vec2 clamp (vec2 x, float minVal, float maxVal) {
    return min (max (x, minVal), maxVal);
}

vec3 clamp (vec3 x, float minVal, float maxVal) {
    return min (max (x, minVal), maxVal);
}

vec4 clamp (vec4 x, float minVal, float maxVal) {
    return min (max (x, minVal), maxVal);
}

vec2 clamp (vec2 x, vec2 minVal, vec2 maxVal) {
    return min (max (x, minVal), maxVal);
}

vec3 clamp (vec3 x, vec3 minVal, vec3 maxVal) {
    return min (max (x, minVal), maxVal);
}

vec4 clamp (vec4 x, vec4 minVal, vec4 maxVal) {
    return min (max (x, minVal), maxVal);
}

float mix (float x, float y, float a) {
    return x * (1.0 - a) + y * a;
}

vec2 mix (vec2 x, vec2 y, float a) {
    return x * (1.0 - a) + y * a;
}

vec3 mix (vec3 x, vec3 y, float a) {
    return x * (1.0 - a) + y * a;
}

vec4 mix (vec4 x, vec4 y, float a) {
    return x * (1.0 - a) + y * a;
}

vec2 mix (vec2 x, vec2 y, vec2 a) {
    return x * (1.0 - a) + y * a;
}

vec3 mix (vec3 x, vec3 y, vec3 a) {
    return x * (1.0 - a) + y * a;
}

vec4 mix (vec4 x, vec4 y, vec4 a) {
    return x * (1.0 - a) + y * a;
}

float step (float edge, float x) {
    return x < edge ? 0.0 : 1.0;
}

vec2 step (vec2 edge, vec2 v) {
    vec2 u;
    u.x = step (edge.x, v.x);
    u.y = step (edge.y, v.y);
    return u;
}

vec3 step (vec3 edge, vec3 v) {
    vec3 u;
    u.x = step (edge.x, v.x);
    u.y = step (edge.y, v.y);
    u.z = step (edge.z, v.z);
    return u;
}

vec4 step (vec4 edge, vec4 v) {
    vec4 u;
    u.x = step (edge.x, v.x);
    u.y = step (edge.y, v.y);
    u.z = step (edge.z, v.z);
    u.w = step (edge.w, v.w);
    return u;
}

vec2 step (float edge, vec2 v) {
    return step (vec2 (edge), v);
}

vec3 step (float edge, vec3 v) {
    return step (vec3 (edge), v);
}

vec4 step (float edge, vec4 v) {
    return step (vec4 (edge), v);
}

float smoothstep (float edge0, float edge1, float x) {
    float t;
    t = clamp ((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

vec2 smoothstep (vec2 edge0, vec2 edge1, vec2 v) {
    vec2 u;
    u.x = smoothstep (edge0.x, edge1.x, v.x);
    u.y = smoothstep (edge0.y, edge1.y, v.y);
    return u;
}

vec3 smoothstep (vec3 edge0, vec3 edge1, vec3 v) {
    vec3 u;
    u.x = smoothstep (edge0.x, edge1.x, v.x);
    u.y = smoothstep (edge0.y, edge1.y, v.y);
    u.z = smoothstep (edge0.z, edge1.z, v.z);
    return u;
}

vec4 smoothstep (vec4 edge0, vec4 edge1, vec4 v) {
    vec4 u;
    u.x = smoothstep (edge0.x, edge1.x, v.x);
    u.y = smoothstep (edge0.y, edge1.y, v.y);
    u.z = smoothstep (edge0.z, edge1.z, v.z);
    u.w = smoothstep (edge0.w, edge1.w, v.w);
    return u;
}

vec2 smoothstep (float edge0, float edge1, vec2 v) {
    vec2 u;
    u.x = smoothstep (edge0, edge1, v.x);
    u.y = smoothstep (edge0, edge1, v.y);
    return u;
}

vec3 smoothstep (float edge0, float edge1, vec3 v) {
    vec3 u;
    u.x = smoothstep (edge0, edge1, v.x);
    u.y = smoothstep (edge0, edge1, v.y);
    u.z = smoothstep (edge0, edge1, v.z);
    return u;
}

vec4 smoothstep (float edge0, float edge1, vec4 v) {
    vec4 u;
    u.x = smoothstep (edge0, edge1, v.x);
    u.y = smoothstep (edge0, edge1, v.y);
    u.z = smoothstep (edge0, edge1, v.z);
    u.w = smoothstep (edge0, edge1, v.w);
    return u;
}

//
// 8.4 Geometric Functions
//

float dot (float x, float y) {
    return x * y;
}

float dot (vec2 v, vec2 u) {
    return v.x * u.x + v.y * u.y;
}

float dot (vec3 v, vec3 u) {
    return v.x * u.x + v.y * u.y + v.z * u.z;
}

float dot (vec4 v, vec4 u) {
    return v.x * u.x + v.y * u.y + v.z * u.z + v.w * u.w;
}

float length (float x) {
    return sqrt (dot (x, x));
}

float length (vec2 v) {
    return sqrt (dot (v, v));
}

float length (vec3 v) {
    return sqrt (dot (v, v));
}

float length (vec4 v) {
    return sqrt (dot (v, v));
}

float distance (float x, float y) {
    return length (x - y);
}

float distance (vec2 v, vec2 u) {
    return length (v - u);
}

float distance (vec3 v, vec3 u) {
    return length (v - u);
}

float distance (vec4 v, vec4 u) {
    return length (v - u);
}

vec3 cross (vec3 v, vec3 u) {
    vec3 t;
    t.x = v.y * u.z - u.y * v.z;
    t.y = v.z * u.x - u.z * v.x;
    t.z = v.x * u.y - u.x * v.y;
    return t;
}

float normalize (float x) {
    return 1.0;
}

vec2 normalize (vec2 v) {
    return v / length (v);
}

vec3 normalize (vec3 v) {
    return v / length (v);
}

vec4 normalize (vec4 v) {
    return v / length (v);
}

float faceforward (float N, float I, float Nref) {
    return dot (Nref, I) < 0.0 ? N : -N;
}

vec2 faceforward (vec2 N, vec2 I, vec2 Nref) {
    return dot (Nref, I) < 0.0 ? N : -N;
}

vec3 faceforward (vec3 N, vec3 I, vec3 Nref) {
    return dot (Nref, I) < 0.0 ? N : -N;
}

vec4 faceforward (vec4 N, vec4 I, vec4 Nref) {
    return dot (Nref, I) < 0.0 ? N : -N;
}

float reflect (float I, float N) {
    return I - 2.0 * dot (N, I) * N;
}

vec2 reflect (vec2 I, vec2 N) {
    return I - 2.0 * dot (N, I) * N;
}

vec3 reflect (vec3 I, vec3 N) {
    return I - 2.0 * dot (N, I) * N;
}

vec4 reflect (vec4 I, vec4 N) {
    return I - 2.0 * dot (N, I) * N;
}

float refract (float I, float N, float eta) {
    float k;
    k = 1.0 - eta * eta * (1.0 - dot (N, I) * dot (N, I));
    if (k < 0.0)
        return 0.0;
    return eta * I - (eta * dot (N, I) + sqrt (k)) * N;
}

vec2 refract (vec2 I, vec2 N, float eta) {
    float k;
    k = 1.0 - eta * eta * (1.0 - dot (N, I) * dot (N, I));
    if (k < 0.0)
        return 0.0;
    return eta * I - (eta * dot (N, I) + sqrt (k)) * N;
}

vec3 refract (vec3 I, vec3 N, float eta) {
    float k;
    k = 1.0 - eta * eta * (1.0 - dot (N, I) * dot (N, I));
    if (k < 0.0)
        return 0.0;
    return eta * I - (eta * dot (N, I) + sqrt (k)) * N;
}

vec4 refract (vec4 I, vec4 N, float eta) {
    float k;
    k = 1.0 - eta * eta * (1.0 - dot (N, I) * dot (N, I));
    if (k < 0.0)
        return 0.0;
    return eta * I - (eta * dot (N, I) + sqrt (k)) * N;
}

//
// 8.5 Matrix Functions
//

mat2 matrixCompMult (mat2 m, mat2 n) {
    mat2 o;
    o[0] = m[0] * n[0];
    o[1] = m[1] * n[1];
    return o;
}

mat3 matrixCompMult (mat3 m, mat3 n) {
    mat3 o;
    o[0] = m[0] * n[0];
    o[1] = m[1] * n[1];
    o[2] = m[2] * n[2];
    return o;
}

mat4 matrixCompMult (mat4 m, mat4 n) {
    mat4 o;
    o[0] = m[0] * n[0];
    o[1] = m[1] * n[1];
    o[2] = m[2] * n[2];
    o[3] = m[3] * n[3];
    return o;
}

//
// 8.6 Vector Relational Functions
//

bvec2 lessThan (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    return b;
}

bvec3 lessThan (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    b.z = v.z < u.z;
    return b;
}

bvec4 lessThan (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    b.z = v.z < u.z;
    b.w = v.w < u.w;
    return b;
}

bvec2 lessThan (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    return b;
}

bvec3 lessThan (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    b.z = v.z < u.z;
    return b;
}

bvec4 lessThan (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x < u.x;
    b.y = v.y < u.y;
    b.z = v.z < u.z;
    b.w = v.w < u.w;
    return b;
}

bvec2 lessThanEqual (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    return b;
}

bvec3 lessThanEqual (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    b.z = v.z <= u.z;
    return b;
}

bvec4 lessThanEqual (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    b.z = v.z <= u.z;
    b.w = v.w <= u.w;
    return b;
}

bvec2 lessThanEqual (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    return b;
}

bvec3 lessThanEqual (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    b.z = v.z <= u.z;
    return b;
}

bvec4 lessThanEqual (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x <= u.x;
    b.y = v.y <= u.y;
    b.z = v.z <= u.z;
    b.w = v.w <= u.w;
    return b;
}

bvec2 greaterThan (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    return b;
}

bvec3 greaterThan (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    b.z = v.z > u.z;
    return b;
}

bvec4 greaterThan (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    b.z = v.z > u.z;
    b.w = v.w > u.w;
    return b;
}

bvec2 greaterThan (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    return b;
}

bvec3 greaterThan (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    b.z = v.z > u.z;
    return b;
}

bvec4 greaterThan (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x > u.x;
    b.y = v.y > u.y;
    b.z = v.z > u.z;
    b.w = v.w > u.w;
    return b;
}

bvec2 greaterThanEqual (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    return b;
}

bvec3 greaterThanEqual (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    b.z = v.z >= u.z;
    return b;
}

bvec4 greaterThanEqual (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    b.z = v.z >= u.z;
    b.w = v.w >= u.w;
    return b;
}

bvec2 greaterThanEqual (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    return b;
}

bvec3 greaterThanEqual (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    b.z = v.z >= u.z;
    return b;
}

bvec4 greaterThanEqual (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x >= u.x;
    b.y = v.y >= u.y;
    b.z = v.z >= u.z;
    b.w = v.w >= u.w;
    return b;
}

bvec2 equal (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    return b;
}

bvec3 equal (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    b.z = v.z == u.z;
    return b;
}

bvec4 equal (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    b.z = v.z == u.z;
    b.w = v.w == u.w;
    return b;
}

bvec2 equal (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    return b;
}

bvec3 equal (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    b.z = v.z == u.z;
    return b;
}

bvec4 equal (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x == u.x;
    b.y = v.y == u.y;
    b.z = v.z == u.z;
    b.w = v.w == u.w;
    return b;
}

bvec2 notEqual (vec2 v, vec2 u) {
    bvec2 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    return b;
}

bvec3 notEqual (vec3 v, vec3 u) {
    bvec3 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    b.z = v.z != u.z;
    return b;
}

bvec4 notEqual (vec4 v, vec4 u) {
    bvec4 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    b.z = v.z != u.z;
    b.w = v.w != u.w;
    return b;
}

bvec2 notEqual (ivec2 v, ivec2 u) {
    bvec2 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    return b;
}

bvec3 notEqual (ivec3 v, ivec3 u) {
    bvec3 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    b.z = v.z != u.z;
    return b;
}

bvec4 notEqual (ivec4 v, ivec4 u) {
    bvec4 b;
    b.x = v.x != u.x;
    b.y = v.y != u.y;
    b.z = v.z != u.z;
    b.w = v.w != u.w;
    return b;
}

bool any (bvec2 v) {
    return v.x || v.y;
}

bool any (bvec3 v) {
    return v.x || v.y || v.z;
}

bool any (bvec4 v) {
    return v.x || v.y || v.z || v.w;
}

bool all (bvec2 v) {
    return v.x && v.y;
}

bool all (bvec3 v) {
    return v.x && v.y && v.z;
}

bool all (bvec4 v) {
    return v.x && v.y && v.z && v.w;
}

bvec2 not (bvec2 v) {
    bvec2 u;
    u.x = !v.x;
    u.y = !v.y;
    return u;
}

bvec3 not (bvec3 v) {
    bvec3 u;
    u.x = !v.x;
    u.y = !v.y;
    u.z = !v.z;
    return u;
}

bvec4 not (bvec4 v) {
    bvec4 u;
    u.x = !v.x;
    u.y = !v.y;
    u.z = !v.z;
    u.w = !v.w;
    return u;
}

//
// 8.7 Texture Lookup Functions
//

vec4 texture1D (sampler1D sampler, float coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 texture1DProj (sampler1D sampler, vec2 coord) {
    return texture1D (sampler, coord.s / coord.t);
}

vec4 texture1DProj (sampler1D sampler, vec4 coord) {
    return texture1D (sampler, coord.s / coord.q);
}

vec4 texture2D (sampler2D sampler, vec2 coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 texture2DProj (sampler2D sampler, vec3 coord) {
    vec2 u;
    u.s = coord.s / coord.p;
    u.t = coord.t / coord.p;
    return texture2D (sampler, u);
}

vec4 texture2DProj (sampler2D sampler, vec4 coord) {
    vec2 u;
    u.s = coord.s / coord.q;
    u.t = coord.t / coord.q;
    return texture2D (sampler, u);
}

vec4 texture3D (sampler3D sampler, vec3 coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 texture3DProj (sampler3D sampler, vec4 coord) {
    vec3 u;
    u.s = coord.s / coord.q;
    u.t = coord.t / coord.q;
    u.p = coord.p / coord.q;
    return texture3D (sampler, u);
}

vec4 textureCube (samplerCube sampler, vec3 coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 shadow1D (sampler1DShadow sampler, vec3 coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 shadow2D (sampler2DShadow sampler, vec3 coord) {
    // XXX:
    return vec4 (0.0);
}

vec4 shadow1DProj (sampler1DShadow sampler, vec4 coord) {
    vec3 u;
    u.s = coord.s / coord.q;
    u.t = 0.0;
    u.p = coord.p / coord.q;
    return shadow1D (sampler, u);
}

vec4 shadow2DProj (sampler2DShadow sampler, vec4 coord) {
    vec3 u;
    u.s = coord.s / coord.q;
    u.t = coord.t / coord.q;
    u.p = coord.p / coord.q;
    return shadow2D (sampler, u);
}

//
// 8.9 Noise Functions
//
// AUTHOR: Stefan Gustavson (stegu@itn.liu.se), Nov 26, 2005
//

float noise1 (float x) {
    float a;
    __asm float_noise1 a, x;
    return a;
}

float noise1 (vec2 x) {
    float a;
    __asm float_noise2 a, x;
    return a;
}

float noise1 (vec3 x) {
    float a;
    __asm float_noise3 a, x;
    return a;
}

float noise1 (vec4 x) {
    float a;
    __asm float_noise4 a, x;
    return a;
}

vec2 noise2 (float x) {
    vec2 u;
    u.x = noise1 (x);
    u.y = noise1 (x + 19.34);
    return u;
}

vec2 noise2 (vec2 x) {
    vec2 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec2 (19.34, 7.66));
    return u;
}

vec2 noise2 (vec3 x) {
    vec2 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec3 (19.34, 7.66, 3.23));
    return u;
}

vec2 noise2 (vec4 x) {
    vec2 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec4 (19.34, 7.66, 3.23, 2.77));
    return u;
}

vec3 noise3 (float x) {
    vec3 u;
    u.x = noise1 (x);
    u.y = noise1 (x + 19.34);
    u.z = noise1 (x + 5.47);
    return u;
}

vec3 noise3 (vec2 x) {
    vec3 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec2 (19.34, 7.66));
    u.z = noise1 (x + vec2 (5.47, 17.85));
    return u;
}

vec3 noise3 (vec3 x) {
    vec3 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec3 (19.34, 7.66, 3.23));
    u.z = noise1 (x + vec3 (5.47, 17.85, 11.04));
    return u;
}

vec3 noise3 (vec4 x) {
    vec3 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec4 (19.34, 7.66, 3.23, 2.77));
    u.z = noise1 (x + vec4 (5.47, 17.85, 11.04, 13.19));
    return u;
}

vec4 noise4 (float x) {
    vec4 u;
    u.x = noise1 (x);
    u.y = noise1 (x + 19.34);
    u.z = noise1 (x + 5.47);
    u.w = noise1 (x + 23.54);
    return u;
}

vec4 noise4 (vec2 x) {
    vec4 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec2 (19.34, 7.66));
    u.z = noise1 (x + vec2 (5.47, 17.85));
    u.w = noise1 (x + vec2 (23.54, 29.11));
    return u;
}

vec4 noise4 (vec3 x) {
    vec4 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec3 (19.34, 7.66, 3.23));
    u.z = noise1 (x + vec3 (5.47, 17.85, 11.04));
    u.w = noise1 (x + vec3 (23.54, 29.11, 31.91));
    return u;
}

vec4 noise4 (vec4 x) {
    vec4 u;
    u.x = noise1 (x);
    u.y = noise1 (x + vec4 (19.34, 7.66, 3.23, 2.77));
    u.z = noise1 (x + vec4 (5.47, 17.85, 11.04, 13.19));
    u.w = noise1 (x + vec4 (23.54, 29.11, 31.91, 37.48));
    return u;
}

