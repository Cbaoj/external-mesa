/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_surface.h"

/* Provides pipe_context's "surface_fill". Commonly used for clearing
 * buffers. */
static void r300_surface_fill(struct pipe_context* pipe,
                              struct pipe_surface* dest,
                              unsigned x, unsigned y,
                              unsigned w, unsigned h,
                              unsigned color)
{
    struct r300_context* r300 = r300_context(pipe);
    CS_LOCALS(r300);
    struct r300_capabilities* caps = ((struct r300_screen*)pipe->screen)->caps;
    float r, g, b, a;
    r = (float)((color >> 16) & 0xff) / 255.0f;
    g = (float)((color >>  8) & 0xff) / 255.0f;
    b = (float)((color >>  0) & 0xff) / 255.0f;
    debug_printf("r300: Filling surface %p at (%d,%d),"
        " dimensions %dx%d, color 0x%x\n",
        dest, x, y, w, h, color);

BEGIN_CS(276);
R300_PACIFY;
OUT_CS_REG(0x4100, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x1D98, 0x43000000);
OUT_CS_REG(0x1D9C, 0x43002000);
OUT_CS_REG(0x1DA0, 0xC3000000);
OUT_CS_REG(0x1DA4, 0x43002000);
OUT_CS_REG(0x1DA8, 0x3F000000);
OUT_CS_REG(0x1DAC, 0x3F000000);
OUT_CS_REG(0x2284, 0x00000000);
OUT_CS_REG(0x20B0, 0x0000043F);
OUT_CS_REG(0x20B4, 0x00000008);
OUT_CS_REG(0x2134, 0x00FFFFFF);
OUT_CS_REG(0x2138, 0x00000000);
OUT_CS_REG(0x2140, 0x00000000);
OUT_CS_REG(0x2150, 0x00000000);
OUT_CS_REG(0x21E0, 0x00000000);
OUT_CS_REG(0x2180, 0x00000000);
OUT_CS_REG(0x2184, 0x00000000);
OUT_CS_REG(0x21DC, 0xAAAAAAAA);
OUT_CS_REG(0x221C, 0x00000000);
OUT_CS_REG(0x2220, 0x3F800000);
OUT_CS_REG(0x2224, 0x3F800000);
OUT_CS_REG(0x2228, 0x3F800000);
OUT_CS_REG(0x222C, 0x3F800000);
OUT_CS_REG(0x2288, 0x0000FFFF);
OUT_CS_REG(0x2090, 0x00000000);
OUT_CS_REG(0x2094, 0x00000000);
OUT_CS_REG(0x22D0, 0x00000000);
OUT_CS_REG(0x22D4, 0x00000000);
OUT_CS_REG(0x22D8, 0x00000000);
OUT_CS_REG(0x4008, 0x00000007);
OUT_CS_REG(0x4010, 0x66666666);
OUT_CS_REG(0x4014, 0x06666666);
/* XXX why doesn't classic Mesa write the number of pipes, too? */
OUT_CS_REG(R300_GB_TILE_CONFIG, R300_GB_TILE_ENABLE | R300_GB_TILE_SIZE_16);
OUT_CS_REG(0x401C, 0x00000004);
OUT_CS_REG(0x4020, 0x00000000);
OUT_CS_REG(0x4104, 0x00000000);
OUT_CS_REG(0x4200, 0x00000000);
OUT_CS_REG(0x4204, 0x00000000);
OUT_CS_REG(0x4208, 0x3F800000);
OUT_CS_REG(0x420C, 0x3F800000);
OUT_CS_REG(0x4214, 0x00050005);
OUT_CS_REG(0x4230, 0x18000006);
OUT_CS_REG(0x4234, 0x00020006);
OUT_CS_REG(0x4238, 0x3BAAAAAB);
OUT_CS_REG(0x4234, 0x00030006);
OUT_CS_REG(0x4260, 0x00000000);
OUT_CS_REG(0x4264, 0x00000000);
OUT_CS_REG(0x4268, 0x3F800000);
OUT_CS_REG(0x4274, 0x00000002);
OUT_CS_REG(0x4278, 0x0003AAAA);
OUT_CS_REG(0x427C, 0x00000000);
OUT_CS_REG(0x4280, 0x00000000);
OUT_CS_REG(0x4288, 0x00000000);
OUT_CS_REG(0x428C, 0x00000001);
OUT_CS_REG(0x4290, 0x00000000);
OUT_CS_REG(0x4294, 0x3DBF1412);
OUT_CS_REG(0x4298, 0x00000000);
OUT_CS_REG(0x42A0, 0x00000000);
OUT_CS_REG(0x42A4, 0x00000000);
OUT_CS_REG(0x42A8, 0x00000000);
OUT_CS_REG(0x42AC, 0x00000000);
OUT_CS_REG(0x42B0, 0x00000000);
OUT_CS_REG(0x42B4, 0x00000000);
OUT_CS_REG(0x42B8, 0x00000000);
OUT_CS_REG(0x42C0, 0x4B7FFFFF);
OUT_CS_REG(0x42C4, 0x00000000);
OUT_CS_REG(0x4300, 0x00000000);
OUT_CS_REG(0x4304, 0x00000000);
OUT_CS_REG(0x4310, 0x00000000);
OUT_CS_REG(0x4314, 0x00000000);
OUT_CS_REG(0x4318, 0x00000000);
OUT_CS_REG(0x431C, 0x00000000);
OUT_CS_REG(0x4320, 0x00000000);
OUT_CS_REG(0x4324, 0x00000000);
OUT_CS_REG(0x4328, 0x00000000);
OUT_CS_REG(0x432C, 0x00000000);
OUT_CS_REG(0x4330, 0x00000000);
OUT_CS_REG(0x43A4, 0x0000001C);
OUT_CS_REG(0x43A8, 0x2DA49525);
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x46A4, 0x00001B00);
OUT_CS_REG(0x46A8, 0x00001B0F);
OUT_CS_REG(0x46AC, 0x00001B0F);
OUT_CS_REG(0x46B0, 0x00001B0F);
OUT_CS_REG(0x46B4, 0x00000001);
OUT_CS_REG(0x4600, 0x00000000);
OUT_CS_REG(0x4604, 0x00000000);
OUT_CS_REG(0x4608, 0x00000000);
OUT_CS_REG(0x4610, 0x00000000);
OUT_CS_REG(0x4614, 0x00000000);
OUT_CS_REG(0x4618, 0x00000000);
OUT_CS_REG(0x461C, 0x00000000);
OUT_CS_REG(0x48C0, 0x00000000);
OUT_CS_REG(0x46C0, 0x00000000);
OUT_CS_REG(0x49C0, 0x00000000);
OUT_CS_REG(0x47C0, 0x00000000);
OUT_CS_REG(0x4BC0, 0x00000002);
OUT_CS_REG(0x4BC8, 0x00000000);
OUT_CS_REG(0x4BCC, 0x00000000);
OUT_CS_REG(0x4BD0, 0x00000000);
OUT_CS_REG(0x4BD4, 0x00000000);
OUT_CS_REG(0x4BD8, 0x00000000);
OUT_CS_REG(0x4BD8, 0x00000000);
OUT_CS_REG(0x4E00, 0x00000000);
OUT_CS_REG(0x4E04, 0x20210000);
OUT_CS_REG(0x4E08, 0x20210000);
OUT_CS_REG(0x4E0C, 0x0000000F);
OUT_CS_REG(0x4E10, 0x00000000);
OUT_CS_REG(0x4E18, 0x00000000);
OUT_CS_REG(0x4E50, 0x00000000);
OUT_CS_REG(0x4E54, 0x00000000);
OUT_CS_REG(0x4E58, 0x00000000);
OUT_CS_REG(0x4E5C, 0x00000000);
OUT_CS_REG(0x4E60, 0x00000000);
OUT_CS_REG(0x4E64, 0x00000000);
OUT_CS_REG(0x4E68, 0x00000000);
OUT_CS_REG(0x4E6C, 0x00000000);
OUT_CS_REG(0x4E70, 0x00000000);
OUT_CS_REG(0x4E88, 0x00000000);
OUT_CS_REG(0x4EA0, 0x00000000);
OUT_CS_REG(0x4EA4, 0xFFFFFFFF);
OUT_CS_REG(0x4F00, 0x00000010);
OUT_CS_REG(0x4F04, 0x00038038);
OUT_CS_REG(0x4F08, 0x00FFFF00);
OUT_CS_REG(0x4F10, 0x00000002);
OUT_CS_REG(0x4F14, 0x00000001);
OUT_CS_REG(0x4F18, 0x00000003);
OUT_CS_REG(0x4F1C, 0x00000000);
OUT_CS_REG(0x4F28, 0x00000000);
OUT_CS_REG(0x4F30, 0x00000000);
OUT_CS_REG(0x4F34, 0x00000000);
OUT_CS_REG(0x4F44, 0x00000000);
OUT_CS_REG(0x4F54, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000406);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x3F800000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000400);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000401);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000402);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000403);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000404);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000405);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2150, 0x21030003);
OUT_CS_REG(0x4BC0, 0x00000000);
OUT_CS_REG(0x21E0, 0xF688F688);
OUT_CS_REG(0x2180, 0x00000001);
OUT_CS_REG(0x2184, 0x00000405);
OUT_CS_REG(0x20B0, 0x0000043F);
OUT_CS_REG(0x20B4, 0x00000008);
OUT_CS_REG(0x21DC, 0xAAAAAAAA);
OUT_CS_REG(0x2090, 0x00000003);
OUT_CS_REG(0x2094, 0x00000000);
OUT_CS_REG(0x4104, 0x00000000);
OUT_CS_REG(0x1D98, 0x3F800000);
OUT_CS_REG(0x1D9C, 0x00000000);
OUT_CS_REG(0x1DA0, 0x3F800000);
OUT_CS_REG(0x1DA4, 0x00000000);
OUT_CS_REG(0x1DA8, 0x3F800000);
OUT_CS_REG(0x1DAC, 0x00000000);
OUT_CS_REG(0x4BD4, 0x00000000);
OUT_CS_REG(0x4E04, 0x00000000);
OUT_CS_REG(0x4E08, 0x00000000);
OUT_CS_REG(0x221C, 0x0001C000);
OUT_CS_REG(R300_GA_POINT_SIZE, ((h * 6) & R300_POINTSIZE_Y_MASK) |
    ((w * 6) << R300_POINTSIZE_X_SHIFT));
OUT_CS_REG(0x4310, 0x00D10000);
OUT_CS_REG(0x4314, 0x00D10000);
OUT_CS_REG(0x4318, 0x00D10000);
OUT_CS_REG(0x431C, 0x00D10000);
OUT_CS_REG(0x4320, 0x00D10000);
OUT_CS_REG(0x4324, 0x00D10000);
OUT_CS_REG(0x4328, 0x00D10000);
OUT_CS_REG(0x432C, 0x00D10000);
OUT_CS_REG(0x4300, 0x00040080);
OUT_CS_REG(0x4304, 0x00000000);
OUT_CS_REG(0x4330, 0x00004000);
OUT_CS_REG(0x4600, 0x00000000);
OUT_CS_REG(0x4604, 0x00000000);
OUT_CS_REG(0x4608, 0x00000000);
OUT_CS_REG(0x4610, 0x00000000);
OUT_CS_REG(0x4614, 0x00000000);
OUT_CS_REG(0x4618, 0x00000000);
OUT_CS_REG(0x461C, 0x00400000);
OUT_CS_REG(0x48C0, 0x00050A80);
OUT_CS_REG(0x46C0, 0x1C000000);
OUT_CS_REG(0x49C0, 0x00040889);
OUT_CS_REG(0x47C0, 0x01000000);
OUT_CS_REG(0x2284, 0x00000000);
/* XXX these magic numbers should be explained when
 * this becomes a cached state object */
OUT_CS_REG(R300_VAP_CNTL, 0xA | (0x5 << R300_PVS_NUM_CNTLRS_SHIFT) |
    (caps->num_vert_fpus << R300_PVS_NUM_FPUS_SHIFT));
OUT_CS_REG(0x22D0, 0x00100000);
OUT_CS_REG(0x22D4, 0x00000000);
OUT_CS_REG(0x22D8, 0x00000001);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2284, 0x00000001);
OUT_CS_REG(0x2200, 0x00000000);
OUT_CS_REG(0x2208, 0x00F00203);
OUT_CS_REG(0x2208, 0x00D10001);
OUT_CS_REG(0x2208, 0x01248001);
OUT_CS_REG(0x2208, 0x00000000);
OUT_CS_REG(0x2208, 0x00F02203);
OUT_CS_REG(0x2208, 0x00D10021);
OUT_CS_REG(0x2208, 0x01248021);
OUT_CS_REG(0x2208, 0x00000000);
R300_PACIFY;
OUT_CS_REG_SEQ(R300_RB3D_COLOROFFSET0, 1);
OUT_CS_RELOC(dest->buffer, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
//OUT_CS_REG(0x4E38, 0x00C00100);
OUT_CS_REG(0x4E0C, 0x0000000F);
OUT_CS_REG(0x4F00, 0x00000000);
OUT_CS_REG(0x4F04, 0x00000000);
OUT_CS_REG(0x4F08, 0x00FF0000);

/* XXX Packet3 */
OUT_CS(CP_PACKET3(R200_3D_DRAW_IMMD_2, 8));
OUT_CS(R300_PRIM_TYPE_POINT | R300_PRIM_WALK_RING |
(1 << R300_PRIM_NUM_VERTICES_SHIFT));
OUT_CS_32F(w / 2.0);
OUT_CS_32F(h / 2.0);
/* XXX this should be the depth value to clear to */
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
OUT_CS_32F(r);
OUT_CS_32F(g);
OUT_CS_32F(b);
OUT_CS_32F(1.0);

OUT_CS_REG(0x4E4C, 0x0000000A);
OUT_CS_REG(0x4F18, 0x00000003);
R300_PACIFY;

END_CS;
FLUSH_CS;

    r300->dirty_state = R300_NEW_KITCHEN_SINK;
}

void r300_init_surface_functions(struct r300_context* r300)
{
    r300->context.surface_fill = r300_surface_fill;
}
