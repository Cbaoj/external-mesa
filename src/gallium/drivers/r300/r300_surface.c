/*
 * Copyright 2008 Corbin Simpson <MostAwesomeDude@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE. */

#include "r300_surface.h"

/* Provides pipe_context's "surface_fill". Commonly used for clearing
 * buffers. */
static void r300_surface_fill(struct pipe_context* pipe,
                              struct pipe_surface* dest,
                              unsigned x, unsigned y,
                              unsigned w, unsigned h,
                              unsigned color)
{
    struct r300_context* r300 = r300_context(pipe);
    CS_LOCALS(r300);
    struct r300_capabilities* caps = ((struct r300_screen*)pipe->screen)->caps;
    int i;
    float r, g, b, a;
    r = (float)((color >> 16) & 0xff) / 255.0f;
    g = (float)((color >>  8) & 0xff) / 255.0f;
    b = (float)((color >>  0) & 0xff) / 255.0f;
    debug_printf("r300: Filling surface %p at (%d,%d),"
        " dimensions %dx%d, color 0x%x\n",
        dest, x, y, w, h, color);

BEGIN_CS(276);
R300_PACIFY;
OUT_CS_REG(R300_TX_INVALTAGS, 0x0);
R300_PACIFY;
/* Viewport setup */
OUT_CS_REG(0x1D98, 0x43000000);
OUT_CS_REG(0x1D9C, 0x43002000);
OUT_CS_REG(0x1DA0, 0xC3000000);
OUT_CS_REG(0x1DA4, 0x43002000);
OUT_CS_REG(0x1DA8, 0x3F000000);
OUT_CS_REG(0x1DAC, 0x3F000000);
/* Flush PVS. */
OUT_CS_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0x0);

OUT_CS_REG(R300_SE_VTE_CNTL, R300_VPORT_X_SCALE_ENA |
    R300_VPORT_X_OFFSET_ENA | R300_VPORT_Y_SCALE_ENA |
    R300_VPORT_Y_OFFSET_ENA | R300_VPORT_Z_SCALE_ENA |
    R300_VPORT_Z_OFFSET_ENA | R300_VTX_W0_FMT);
/* Vertex size. */
OUT_CS_REG(R300_VAP_VTX_SIZE, 0x8);
/* Max and min vertex index clamp. */
OUT_CS_REG(R300_VAP_VF_MAX_VTX_INDX, 0xFFFFFF);
OUT_CS_REG(R300_VAP_VF_MIN_VTX_INDX, 0x0);
/* XXX endian */
OUT_CS_REG(R300_VAP_CNTL_STATUS, R300_VC_NO_SWAP);
OUT_CS_REG(R300_VAP_PROG_STREAM_CNTL_0, 0x0);
/* XXX magic number not in r300_reg */
OUT_CS_REG(R300_VAP_PSC_SGN_NORM_CNTL, 0xAAAAAAAA);
OUT_CS_REG(R300_VAP_CLIP_CNTL, 0x0);
OUT_CS_REG(R300_VAP_GB_VERT_CLIP_ADJ, 4);
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
/* XXX is this too long? */
OUT_CS_REG(VAP_PVS_VTX_TIMEOUT_REG, 0xFFFF);
OUT_CS_REG(R300_GB_ENABLE, R300_GB_POINT_STUFF_ENABLE |
    R300_GB_LINE_STUFF_ENABLE | R300_GB_TRIANGLE_STUFF_ENABLE);
/* XXX more magic numbers */
OUT_CS_REG(R300_GB_MSPOS0, 0x66666666);
OUT_CS_REG(R300_GB_MSPOS1, 0x66666666);
/* XXX why doesn't classic Mesa write the number of pipes, too? */
OUT_CS_REG(R300_GB_TILE_CONFIG, R300_GB_TILE_ENABLE | R300_GB_TILE_SIZE_16);
OUT_CS_REG(R300_GB_SELECT, R300_GB_FOG_SELECT_1_1_W);
OUT_CS_REG(R300_GB_AA_CONFIG, 0x0);
/* XXX point tex stuffing */
OUT_CS_REG_SEQ(R300_GA_POINT_S0, 4);
OUT_CS_32F(0.0);
OUT_CS_32F(0.0);
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
OUT_CS_REG(0x4214, 0x00050005);
OUT_CS_REG(0x4230, 0x18000006);
OUT_CS_REG(0x4234, 0x00020006);
OUT_CS_REG(0x4238, 0x3BAAAAAB);
OUT_CS_REG(0x4234, 0x00030006);
OUT_CS_REG(0x4260, 0x00000000);
OUT_CS_REG(0x4264, 0x00000000);
OUT_CS_REG(0x4268, 0x3F800000);
OUT_CS_REG(0x4274, 0x00000002);
OUT_CS_REG(0x4278, 0x0003AAAA);
OUT_CS_REG(0x427C, 0x00000000);
OUT_CS_REG(0x4280, 0x00000000);
OUT_CS_REG(0x4288, 0x00000000);
OUT_CS_REG(0x428C, 0x00000001);
OUT_CS_REG(0x4290, 0x00000000);
OUT_CS_REG(0x4294, 0x3DBF1412);
OUT_CS_REG(0x4298, 0x00000000);
OUT_CS_REG(0x42A0, 0x00000000);
OUT_CS_REG(0x42A4, 0x00000000);
OUT_CS_REG(0x42A8, 0x00000000);
OUT_CS_REG(0x42AC, 0x00000000);
OUT_CS_REG(0x42B0, 0x00000000);
OUT_CS_REG(0x42B4, 0x00000000);
OUT_CS_REG(0x42B8, 0x00000000);
OUT_CS_REG(0x42C0, 0x4B7FFFFF);
OUT_CS_REG(0x42C4, 0x00000000);
OUT_CS_REG(0x43A4, 0x0000001C);
OUT_CS_REG(0x43A8, 0x2DA49525);
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x46A4, 0x00001B00);
OUT_CS_REG(0x46A8, 0x00001B0F);
OUT_CS_REG(0x46AC, 0x00001B0F);
OUT_CS_REG(0x46B0, 0x00001B0F);
OUT_CS_REG(0x46B4, 0x00000001);
OUT_CS_REG(0x4600, 0x00000000);
OUT_CS_REG(0x4604, 0x00000000);
OUT_CS_REG(0x4608, 0x00000000);
OUT_CS_REG(0x4610, 0x00000000);
OUT_CS_REG(0x4614, 0x00000000);
OUT_CS_REG(0x4618, 0x00000000);
OUT_CS_REG(0x461C, 0x00000000);
OUT_CS_REG(0x48C0, 0x00000000);
OUT_CS_REG(0x46C0, 0x00000000);
OUT_CS_REG(0x49C0, 0x00000000);
OUT_CS_REG(0x47C0, 0x00000000);
OUT_CS_REG(0x4BC0, 0x00000002);
OUT_CS_REG(0x4BC8, 0x00000000);
OUT_CS_REG(0x4BCC, 0x00000000);
OUT_CS_REG(0x4BD0, 0x00000000);
OUT_CS_REG(0x4BD8, 0x00000000);
OUT_CS_REG(0x4BD8, 0x00000000);
OUT_CS_REG(0x4E00, 0x00000000);
OUT_CS_REG(0x4E0C, 0x0000000F);

r300_emit_blend_color_state(r300, &blend_color_clear_state);

OUT_CS_REG(0x4E10, 0x00000000);
OUT_CS_REG(0x4E54, 0x00000000);
OUT_CS_REG(0x4E58, 0x00000000);
OUT_CS_REG(0x4E5C, 0x00000000);
OUT_CS_REG(0x4E60, 0x00000000);
OUT_CS_REG(0x4E64, 0x00000000);
OUT_CS_REG(0x4E68, 0x00000000);
OUT_CS_REG(0x4E6C, 0x00000000);
OUT_CS_REG(0x4E70, 0x00000000);
OUT_CS_REG(0x4E88, 0x00000000);
OUT_CS_REG(0x4EA0, 0x00000000);
OUT_CS_REG(0x4EA4, 0xFFFFFFFF);
OUT_CS_REG(0x4F00, 0x00000010);
OUT_CS_REG(0x4F04, 0x00038038);
OUT_CS_REG(0x4F08, 0x00FFFF00);
OUT_CS_REG(0x4F10, 0x00000002);
OUT_CS_REG(0x4F18, 0x00000003);
OUT_CS_REG(0x4F1C, 0x00000000);
OUT_CS_REG(0x4F28, 0x00000000);
OUT_CS_REG(0x4F30, 0x00000000);
OUT_CS_REG(0x4F34, 0x00000000);
OUT_CS_REG(0x4F44, 0x00000000);
OUT_CS_REG(0x4F54, 0x00000000);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
OUT_CS_REG(0x2150, 0x21030003);
OUT_CS_REG(0x4BC0, 0x00000000);
OUT_CS_REG(R300_VAP_PROG_STREAM_CNTL_EXT_0, 0xF688F688);
OUT_CS_REG(R300_VAP_VTX_STATE_CNTL, 0x1);
OUT_CS_REG(R300_VAP_VSM_VTX_ASSM, 0x405);
OUT_CS_REG(0x20B0, 0x0000043F);
OUT_CS_REG(0x20B4, 0x00000008);
OUT_CS_REG(0x21DC, 0xAAAAAAAA);
OUT_CS_REG(0x2090, 0x00000003);
OUT_CS_REG(0x2094, 0x00000000);
OUT_CS_REG(R300_TX_ENABLE, 0x0);
OUT_CS_REG(0x1D98, 0x3F800000);
OUT_CS_REG(0x1D9C, 0x00000000);
OUT_CS_REG(0x1DA0, 0x3F800000);
OUT_CS_REG(0x1DA4, 0x00000000);
OUT_CS_REG(0x1DA8, 0x3F800000);
OUT_CS_REG(0x1DAC, 0x00000000);
OUT_CS_REG(0x4BD4, 0x00000000);

r300_emit_blend_state(r300, &blend_clear_state);

OUT_CS_REG(0x221C, 0x0001C000);
OUT_CS_REG(R300_GA_POINT_SIZE, ((h * 6) & R300_POINTSIZE_Y_MASK) |
    ((w * 6) << R300_POINTSIZE_X_SHIFT));

/* XXX RS block setup */
if (caps->is_r500) {
    OUT_CS_REG_SEQ(R500_RS_IP_0, 8);
    for (i = 0; i < 8; i++) {
        /* I like the operator macros more than the shift macros... */
        OUT_CS((R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_S_SHIFT) |
            (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_T_SHIFT) |
            (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_R_SHIFT) |
            (R500_RS_IP_PTR_K1 << R500_RS_IP_TEX_PTR_Q_SHIFT));
    }
} else {
    OUT_CS_REG_SEQ(R300_RS_IP_0, 8);
    for (i = 0; i < 8; i++) {
        OUT_CS(R300_RS_SEL_T(1) | R300_RS_SEL_R(2) | R300_RS_SEL_Q(3));
    }
}
OUT_CS_REG(R300_RS_COUNT, (1 << R300_IC_COUNT_SHIFT) | R300_HIRES_EN);
OUT_CS_REG(R300_RS_INST_COUNT, 0x0);

OUT_CS_REG(0x4330, 0x00004000);
OUT_CS_REG(0x4600, 0x00000000);
OUT_CS_REG(0x4604, 0x00000000);
OUT_CS_REG(0x4608, 0x00000000);
OUT_CS_REG(0x4610, 0x00000000);
OUT_CS_REG(0x4614, 0x00000000);
OUT_CS_REG(0x4618, 0x00000000);
OUT_CS_REG(0x461C, 0x00400000);
OUT_CS_REG(0x48C0, 0x00050A80);
OUT_CS_REG(0x46C0, 0x1C000000);
OUT_CS_REG(0x49C0, 0x00040889);
OUT_CS_REG(0x47C0, 0x01000000);
/* XXX these magic numbers should be explained when
 * this becomes a cached state object */
OUT_CS_REG(R300_VAP_CNTL, 0xA | (0x5 << R300_PVS_NUM_CNTLRS_SHIFT) |
    (caps->num_vert_fpus << R300_PVS_NUM_FPUS_SHIFT));
OUT_CS_REG(0x22D0, 0x00100000);
OUT_CS_REG(0x22D4, 0x00000000);
OUT_CS_REG(0x22D8, 0x00000001);
OUT_CS_REG(0x43E8, 0x00000000);
R300_PACIFY;
OUT_CS_REG(0x43E8, 0x00FFFFFF);
/* XXX translate these back into normal instructions */
OUT_CS_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0x1);
OUT_CS_REG(R300_VAP_PVS_VECTOR_INDX_REG, 0x0);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0xF00203);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0xD10001);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0x1248001);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0x0);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0xF02203);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0xD10021);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0x1248021);
OUT_CS_REG(R300_VAP_PVS_UPLOAD_DATA, 0x0);

r300_emit_dsa_state(r300, &dsa_clear_state);

R300_PACIFY;
OUT_CS_REG_SEQ(R300_RB3D_COLOROFFSET0, 1);
OUT_CS_RELOC(dest->buffer, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
//OUT_CS_REG(0x4E38, 0x00C00100);
OUT_CS_REG(0x4E0C, 0x0000000F);
/* XXX Packet3 */
OUT_CS(CP_PACKET3(R200_3D_DRAW_IMMD_2, 8));
OUT_CS(R300_PRIM_TYPE_POINT | R300_PRIM_WALK_RING |
(1 << R300_PRIM_NUM_VERTICES_SHIFT));
OUT_CS_32F(w / 2.0);
OUT_CS_32F(h / 2.0);
/* XXX this should be the depth value to clear to */
OUT_CS_32F(1.0);
OUT_CS_32F(1.0);
OUT_CS_32F(r);
OUT_CS_32F(g);
OUT_CS_32F(b);
OUT_CS_32F(1.0);

/* XXX figure out why this is 0xA and not 0x2 */
/* XXX OUT_CS_REG(R300_RB3D_DSTCACHE_CTLSTAT, 0xA);
OUT_CS_REG(R300_ZB_ZCACHE_CTLSTAT,
    R300_ZB_ZCACHE_CTLSTAT_ZC_FLUSH_FLUSH_AND_FREE |
    R300_ZB_ZCACHE_CTLSTAT_ZC_FREE_FREE); */
R300_PACIFY;

END_CS;
FLUSH_CS;

    r300->dirty_state = R300_NEW_KITCHEN_SINK;
}

void r300_init_surface_functions(struct r300_context* r300)
{
    r300->context.surface_fill = r300_surface_fill;
}
