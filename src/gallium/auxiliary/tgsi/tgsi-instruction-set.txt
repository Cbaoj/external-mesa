TGSI Instruction Specification
==============================
==============================


1  Instruction Set Operations
=============================


1.1  GL_NV_vertex_program
-------------------------


1.1.1  ARL - Address Register Load

  dst.x = floor(src.x)
  dst.y = floor(src.y)
  dst.z = floor(src.z)
  dst.w = floor(src.w)


1.1.2  MOV - Move

  dst.x = src.x
  dst.y = src.y
  dst.z = src.z
  dst.w = src.w


1.1.3  LIT - Light Coefficients

  dst.x = 1.0
  dst.y = max(src.x, 0.0)
  dst.z = (src.x > 0.0) ? pow(max(src.y, 0.0), clamp(src.w, -128.0, 128.0)) : 0.0
  dst.w = 1.0


1.1.4  RCP - Reciprocal

  dst.x = 1.0 / src.x
  dst.y = 1.0 / src.x
  dst.z = 1.0 / src.x
  dst.w = 1.0 / src.x


1.1.5  RSQ - Reciprocal Square Root

  dst.x = 1.0 / sqrt(abs(src.x))
  dst.y = 1.0 / sqrt(abs(src.x))
  dst.z = 1.0 / sqrt(abs(src.x))
  dst.w = 1.0 / sqrt(abs(src.x))


1.1.6  EXP - Approximate Exponential Base 2

  dst.x = pow(2.0, floor(src.x))
  dst.y = src.x - floor(src.x)
  dst.z = pow(2.0, src.x)
  dst.w = 1.0


1.1.7  LOG - Approximate Logarithm Base 2

  dst.x = floor(lg2(abs(src.x)))
  dst.y = abs(src.x) / pow(2.0, floor(lg2(abs(src.x))))
  dst.z = lg2(abs(src.x))
  dst.w = 1.0


1.1.8  MUL - Multiply

  dst.x = src0.x * src1.x
  dst.y = src0.y * src1.y
  dst.z = src0.z * src1.z
  dst.w = src0.w * src1.w


1.1.9  ADD - Add

  dst.x = src0.x + src1.x
  dst.y = src0.y + src1.y
  dst.z = src0.z + src1.z
  dst.w = src0.w + src1.w


1.1.10  DP3 - 3-component Dot Product

  dst.x = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z
  dst.y = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z
  dst.z = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z
  dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z


1.1.11  DP4 - 4-component Dot Product

  dst.x = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src0.w * src1.w
  dst.y = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src0.w * src1.w
  dst.z = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src0.w * src1.w
  dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src0.w * src1.w


1.1.12  DST - Distance Vector

  dst.x = 1.0
  dst.y = src0.y * src1.y
  dst.z = src0.z
  dst.w = src1.w


1.1.13  MIN - Minimum

  dst.x = min(src0.x, src1.x)
  dst.y = min(src0.y, src1.y)
  dst.z = min(src0.z, src1.z)
  dst.w = min(src0.w, src1.w)


1.1.14  MAX - Maximum

  dst.x = max(src0.x, src1.x)
  dst.y = max(src0.y, src1.y)
  dst.z = max(src0.z, src1.z)
  dst.w = max(src0.w, src1.w)


1.1.15  SLT - Set On Less Than

  dst.x = (src0.x < src1.x) ? 1.0 : 0.0
  dst.y = (src0.y < src1.y) ? 1.0 : 0.0
  dst.z = (src0.z < src1.z) ? 1.0 : 0.0
  dst.w = (src0.w < src1.w) ? 1.0 : 0.0


1.1.16  SGE - Set On Greater Equal Than

  dst.x = (src0.x >= src1.x) ? 1.0 : 0.0
  dst.y = (src0.y >= src1.y) ? 1.0 : 0.0
  dst.z = (src0.z >= src1.z) ? 1.0 : 0.0
  dst.w = (src0.w >= src1.w) ? 1.0 : 0.0


1.1.17  MAD - Multiply And Add

  dst.x = src0.x * src1.x + src2.x
  dst.y = src0.y * src1.y + src2.y
  dst.z = src0.z * src1.z + src2.z
  dst.w = src0.w * src1.w + src2.w


1.2  GL_ATI_fragment_shader
---------------------------


1.2.1  SUB - Subtract

  dst.x = src0.x - src1.x
  dst.y = src0.y - src1.y
  dst.z = src0.z - src1.z
  dst.w = src0.w - src1.w


1.2.2  DOT3 - 3-component Dot Product

  Alias for DP3.


1.2.3  DOT4 - 4-component Dot Product

  Alias for DP4.


1.2.4  LERP - Linear Interpolate

  dst.x = src0.x * (src1.x - src2.x) + src2.x
  dst.y = src0.y * (src1.y - src2.y) + src2.y
  dst.z = src0.z * (src1.z - src2.z) + src2.z
  dst.w = src0.w * (src1.w - src2.w) + src2.w


1.2.5  CND - Condition

  dst.x = (src2.x > 0.5) ? src0.x : src1.x
  dst.y = (src2.y > 0.5) ? src0.y : src1.y
  dst.z = (src2.z > 0.5) ? src0.z : src1.z
  dst.w = (src2.w > 0.5) ? src0.w : src1.w


1.2.6  CND0 - Condition Zero

  dst.x = (src2.x >= 0.0) ? src0.x : src1.x
  dst.y = (src2.y >= 0.0) ? src0.y : src1.y
  dst.z = (src2.z >= 0.0) ? src0.z : src1.z
  dst.w = (src2.w >= 0.0) ? src0.w : src1.w


1.2.7  DOT2ADD - 2-component Dot Product And Add

  dst.x = src0.x * src1.x + src0.y * src1.y + src2.x
  dst.y = src0.x * src1.x + src0.y * src1.y + src2.x
  dst.z = src0.x * src1.x + src0.y * src1.y + src2.x
  dst.w = src0.x * src1.x + src0.y * src1.y + src2.x


1.3  GL_EXT_vertex_shader
-------------------------


1.3.1  INDEX - Array Lookup

  Considered for removal from language.


1.3.2  NEGATE - Negate

  Considered for removal from language.


1.3.3  MADD - Multiply And Add

  Alias for MAD.


1.3.4  FRAC - Fraction

  dst.x = src.x - floor(src.x)
  dst.y = src.y - floor(src.y)
  dst.z = src.z - floor(src.z)
  dst.w = src.w - floor(src.w)


1.3.5  SETGE - Set On Greater Equal

  Alias for SGE.


1.3.6  SETLT - Set On Less Than

  Alias for SLT.


1.3.7  CLAMP - Clamp

  dst.x = clamp(src0.x, src1.x, src2.x)
  dst.y = clamp(src0.y, src1.y, src2.y)
  dst.z = clamp(src0.z, src1.z, src2.z)
  dst.w = clamp(src0.w, src1.w, src2.w)


1.3.8  FLOOR - Floor

  dst.x = floor(src.x)
  dst.y = floor(src.y)
  dst.z = floor(src.z)
  dst.w = floor(src.w)


1.3.9  ROUND - Round

  dst.x = round(src.x)
  dst.y = round(src.y)
  dst.z = round(src.z)
  dst.w = round(src.w)


1.3.10  EXPBASE2 - Exponent Base 2

  dst.x = pow(2.0, src.x)
  dst.y = pow(2.0, src.x)
  dst.z = pow(2.0, src.x)
  dst.w = pow(2.0, src.x)


1.3.11  LOGBASE2 - Logarithm Base 2

  dst.x = lg2(src.x)
  dst.y = lg2(src.x)
  dst.z = lg2(src.x)
  dst.w = lg2(src.x)


1.3.12  POWER - Power

  dst.x = pow(src0.x, src1.x)
  dst.y = pow(src0.x, src1.x)
  dst.z = pow(src0.x, src1.x)
  dst.w = pow(src0.x, src1.x)


1.3.13  RECIP - Reciprocal

  Alias for RCP.


1.3.14  RECIPSQRT - Reciprocal Square Root

  Alias for RSQ.


1.3.15  CROSSPRODUCT - Cross Product

  dst.x = src0.y * src1.z - src1.y * src0.z
  dst.y = src0.z * src1.x - src1.z * src0.x
  dst.z = src0.x * src1.y - src1.x * src0.y
  dst.w = 1.0


1.3.16  MULTIPLYMATRIX - Multiply Matrix

  Considered for removal from language.


1.4  GL_NV_vertex_program1_1
----------------------------


1.4.1  ABS - Absolute

  dst.x = abs(src.x)
  dst.y = abs(src.y)
  dst.z = abs(src.z)
  dst.w = abs(src.w)


1.4.2  RCC - Reciprocal Clamped

  dst.x = (1.0 / src.x) > 0.0 ? clamp(1.0 / src.x, 5.42101e-020, 1.884467e+019) : clamp(1.0 / src.x, -1.884467e+019, -5.42101e-020)
  dst.y = (1.0 / src.x) > 0.0 ? clamp(1.0 / src.x, 5.42101e-020, 1.884467e+019) : clamp(1.0 / src.x, -1.884467e+019, -5.42101e-020)
  dst.z = (1.0 / src.x) > 0.0 ? clamp(1.0 / src.x, 5.42101e-020, 1.884467e+019) : clamp(1.0 / src.x, -1.884467e+019, -5.42101e-020)
  dst.w = (1.0 / src.x) > 0.0 ? clamp(1.0 / src.x, 5.42101e-020, 1.884467e+019) : clamp(1.0 / src.x, -1.884467e+019, -5.42101e-020)


1.4.3  DPH - Homogeneous Dot Product

  dst.x = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w
  dst.y = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w
  dst.z = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w
  dst.w = src0.x * src1.x + src0.y * src1.y + src0.z * src1.z + src1.w

